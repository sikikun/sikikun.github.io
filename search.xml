<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF-LSTM</title>
      <link href="/CF-LSTM.html"/>
      <url>/CF-LSTM.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>CF-LSTM: Cascaded Feature-Based Long Short-Term Networks for Predicting Pedestrian Trajectory</p></blockquote><a id="more"></a><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>仅提取空间信息不够，行人场景需要提取速度信息</li><li>neighboring interaction在不同场景中对预测轨迹影响不同</li><li>提出特征级联模块及相应框架CF-LSTM</li></ul><hr><h2 id="本文综述"><a href="#本文综述" class="headerlink" title="本文综述"></a>本文综述</h2><ul><li>提出不需要额外人工设置和社会规则的特征层联的LSTM网络。</li><li>特征信息从前两个时间步提取出来，然后整合为一个级联特征输入到LSTM中；同时捕获到先前的位置和动态速度信息。</li><li>场景不可知的层联特征是人与人交互的外在表现，所以可以有效的捕捉不同场景的行人动态交互信息，而不需要其他行人的信息。<strong>也就是说本文获取临近行人信息是通过研究的agent自身级联特征获取而不是通过其他行人信息获取。</strong></li></ul><hr><h2 id="图说"><a href="#图说" class="headerlink" title="图说"></a>图说</h2><p>Figure 1. 交互包含行人与场景(静态)和行人间的交互(动态)，后者更加复杂。<br>Figure 2. CF-LSTM模型概述，EM提取模块/IM推理模块/CF级联特征模块。<br>Table 1. CF-LSTM和P-LSTM的表现ADE/FDE比较（ETH/Hotel/ZARA01/ZARA02/UCY）。<br>Table 2. 和其他模型的表现ADE/FDE比较（ETH/Hotel/ZARA01/ZARA02/UCY）。<br>Figure 3. 每帧的误差变化，x轴是帧数（1-12），y轴代表ADE大小。<br>Figure 4. 被预测轨迹的行人数量变化。<br>Figure 5. 预测轨迹的图像。横向对比了observation/Ground truth/CF-LSTM/S-LSTM，纵向对比了不同场景如碰撞避免/单独或成群行走/不同速度行走等情况。</p><hr><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><h3 id="之前的LSTM"><a href="#之前的LSTM" class="headerlink" title="之前的LSTM"></a>之前的LSTM</h3><p>定义三个输入：当前位置的特征信息；之前时间步的特征信息；动态交互的特征信息<br>有两个局限性：</p><ol><li>仅从上一个时间步获取的特征信息是不够充分的，因为这仅捕捉了行人先前的空间特征，它只代表了先前的位置信息而忽略了速度信息。比如一个行人突然开始行走或者突然改变步行速度。</li><li>不同场景中neighbor动态交互信息不可靠。许多研究都是通过设计一个额外的层来提取neighboring交互信息；这些研究主要集中在某一特定时刻的交互行为。实际上，在不同场景中行人会有不同考量。动态交互对未来轨迹的影响在不同场景中可能会产生变化，比如稀疏场景和拥挤场景中，这些影响未被考量。<h3 id="CF-LSTM针对局限性的创新"><a href="#CF-LSTM针对局限性的创新" class="headerlink" title="CF-LSTM针对局限性的创新"></a>CF-LSTM针对局限性的创新</h3></li><li>从前两个时间步中提取特征信息，然后整合为一个特征作为LSTM的输入。因为是两个时间步，所以位置特征和速度特征都会被考量进去。</li><li>不考虑复杂的行人之间的交互，而是关注动态交互的内在动机。不管场景如何，行人间交互本质都是行人改变自身位置；而速度特征（级联特征）也可以解释不同场景的动态交互。<h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3>与行人间交互模型不同/LSTM/<br>Feature-Cascaded Framework受到了Residual Learning的启发。残差学习可以从之前层获取历史信息（即特征映射），CF-LSTM是通过提取前两个时间步并且集成然后输入LSTM。<h3 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h3><img src="https://i.niupic.com/images/2020/08/01/8tQM.png" alt=""><br>在Vanilla-LSTM中给行人i坐标编码(xi,yi)；通过三个关键的模块：EM/CF/IM进行改进。<br>先通过EM提取行人i在t-1和t-2时刻的隐状态，然后输入到CF中，通过前两个时间步形成级联特征，最后通过t时刻的隐状态结合IM推断t+1时刻位置。<h4 id="EM-Extracting-Module"><a href="#EM-Extracting-Module" class="headerlink" title="EM(Extracting Module):"></a>EM(Extracting Module):</h4><img src="https://i.niupic.com/images/2020/08/01/8tPQ.png" alt=""><h4 id="CF-Cascaded-Feature-Module"><a href="#CF-Cascaded-Feature-Module" class="headerlink" title="CF(Cascaded Feature Module):"></a>CF(Cascaded Feature Module):</h4><img src="https://i.niupic.com/images/2020/08/01/8tPT.png" alt=""><br>我们可以看出来在重写之后，原式的第一项是先前的位置信息，而后一项代表的是动态速度信息。所以经过级联之后隐状态不光包含了位置信息，也包含了动态速度信息。在这之后，ht就可以作为正常LSTM网络中的隐状态输入。<h4 id="IM-Inference-Module"><a href="#IM-Inference-Module" class="headerlink" title="IM(Inference Module):"></a>IM(Inference Module):</h4>用一个二维高斯分布来预估坐标，预估参数有μx，μy，σx，σy和相关系数ρ，这些参数在t时刻根据t时刻的隐状态加上一个全连接层来表示：<br><img src="https://i.niupic.com/images/2020/08/01/8tQ4.png" alt=""><br>预测坐标给出的形式为：<br><img src="https://i.niupic.com/images/2020/08/01/8tQ8.png" alt=""><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4>负对数似然损失<br><img src="https://i.niupic.com/images/2020/08/01/8tQ9.png" alt=""><h4 id="CF表现出速度后的好处？"><a href="#CF表现出速度后的好处？" class="headerlink" title="CF表现出速度后的好处？"></a>CF表现出速度后的好处？</h4>为了体现CF的有效性，论文设置了Perceptive Feature Module作为对比：<br><img src="https://i.niupic.com/images/2020/08/01/8tQi.png" alt=""><br>这种ht每一列由t-1和t-2时刻相应列计算的关系不存在，速度关系便表示不出来，于是效果便不如CF模块好(Table 2) 一个可行的解释是隐藏状态h不同列的值代表高维特征空间中的一个显著特征，直接MLP会导致高维特征空间中特征混乱。<h3 id="实验结果和分析"><a href="#实验结果和分析" class="headerlink" title="实验结果和分析"></a>实验结果和分析</h3><h4 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h4>ADE/FDE<h4 id="对比基准"><a href="#对比基准" class="headerlink" title="对比基准"></a>对比基准</h4>LSTM，S-LSTM，S-GAN，SoPhie，将提出的框架引入S-LSTM中形成的CF-S-LSTM<h4 id="训练细节"><a href="#训练细节" class="headerlink" title="训练细节"></a>训练细节</h4></li></ol><ul><li>obs 8 frames predict 12 frames</li><li>LSTM隐状态维度 128 ； 输入嵌入64维再经过ReLU非线性化</li><li>batch size 8</li><li>150 epochs</li><li>Adam 学习率0.001</li><li>预测过程中下一时间步使用的实际坐标是上一个分布中采样获得的预测坐标。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> predict trajectory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代计算机图形学入门07</title>
      <link href="/graphics3.html"/>
      <url>/graphics3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>GAMES101-现代计算机图形学入门 Lecture 07</p></blockquote><a id="more"></a><h1 id="07-Shading-1-Visibility-Shading-intro-Diffuse-reflection"><a href="#07-Shading-1-Visibility-Shading-intro-Diffuse-reflection" class="headerlink" title="07-Shading 1(Visibility/Shading intro/Diffuse reflection)"></a>07-Shading 1(Visibility/Shading intro/Diffuse reflection)</h1><h2 id="Visibility-occlusion"><a href="#Visibility-occlusion" class="headerlink" title="Visibility/occlusion"></a>Visibility/occlusion</h2><p>Z - buffering 深度缓冲/深度缓存: 我们怎么确定各个光栅化三角形的前后关系?</p><h3 id="Painter’s-Algorithm"><a href="#Painter’s-Algorithm" class="headerlink" title="Painter’s Algorithm:"></a>Painter’s Algorithm:</h3><p>先放什么后放什么:先放最远的,逐渐用近的物体覆盖上去<br>顺序非常讲究了! 我们定义深度(离观测点的距离不容易)<br>将n个三角形进行排序时间复杂度o(nlogn)<br>当两两三角形覆盖的时候(环)我们便没法定义深度关系,自然无法使用画家算法解决</p><h3 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h3><p>这是我们现在广泛使用的算法<br>我们对每个三角形不好计算远近关系,但我们对于每个像素可以进行深度计算<br>在生成图像(frame buffer)的同时,同时生成一个深度图(depth buffer)存储像素的深度信息<br><strong>为了简化我们假设z永远是正值(区别之前的相机视图看向-z方向)即远大近小</strong><br>Z-Buffer Algorithm:</p><pre><code>初始化depth buffer to infinite;During rasterization:    for(each triangle T)        for(each sample (x,y,z)in T)            if(z &lt; zbuffer[x,y])            //目前最近的像素                framebuffer[x,y] = rgb;     //更新颜色                zbuffer[x,y] = z;           //更新深度            else;</code></pre><p><img src="https://pic.downk.cc/item/5eccc81fc2a9a83be5ebaf43.png" alt=""></p><p>complexity:我们假设每个三角形都覆盖常数大小的像素,对于n个三角形o(n)→因为我们这里不是进行排序,而是只记录最小值</p><p>那我们绘制三角形的顺序是否有关?无关(假设没有同样深度的像素点)浮点型和浮点型判断相等非常非常困难,所以我们基本上可以认为浮点数不相等.(如何处理相等本课不涉及)</p><p><strong>Most important visibility algorithm:implemented in hardware for all GPSu</strong></p><p>Addtion:在MSAA,我们便不是对每个像素做而是对每个采样点做depth buffer</p><h2 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading-着色"></a>Shading-着色</h2><p><img src="https://i.loli.net/2020/05/26/2wsVbgYHZkMGmI8.png" alt="微信截图_20200526160806.png"><br>In this course, we define shading as the process of applying a material to an object.(明暗/颜色)</p><h3 id="Illumination-amp-Shading"><a href="#Illumination-amp-Shading" class="headerlink" title="Illumination &amp; Shading"></a>Illumination &amp; Shading</h3><p>最简单的着色模型Blinn-Phong反射模型:<br><img src="https://i.niupic.com/images/2020/05/26/856m.png" alt=""><br>Specular highlights-镜面高光<br>Diffuse reflection-漫反射<br>Ambient lighting-环境光源(间接光照)</p><h3 id="预定义一些东西"><a href="#预定义一些东西" class="headerlink" title="预定义一些东西"></a>预定义一些东西</h3><p>我们可以认为局部范围内shading是作用在平面上,同样我们可以定义法线<em>n</em>方向.另外可以规定观测方向<em>v</em>,光源的光照方向<em>l</em>.计算光线时是作用在一个特定的shading point上<br><img src="https://i.niupic.com/images/2020/05/26/85dm.png" alt=""><br><strong>Shading! = shadow</strong> 我们只考虑光照观测,不考虑其他物体造成的阴影</p><blockquote><p><strong><em>shading is local</em></strong></p></blockquote><h3 id="漫反射Diffuse-Reflection"><a href="#漫反射Diffuse-Reflection" class="headerlink" title="漫反射Diffuse Reflection"></a>漫反射Diffuse Reflection</h3><p>光线将会均匀的反射到不同方向去 But is it easy?<br>我们能够接受多少光线?我们考虑到光是能量,实际观测到明亮程度就是光通量的大小问题.</p><blockquote><p>考虑shading point周围能接受多少能量<br>Lamber’s cosine law<br><img src="https://i.niupic.com/images/2020/05/26/85eE.png" alt=""></p></blockquote><h3 id="光线衰减"><a href="#光线衰减" class="headerlink" title="光线衰减"></a>光线衰减</h3><p>考虑能量守恒,光的强度和距离的平方成反比,由此我们就可以得到有多少光从点光源传播到shading point,我们又结合lamber’s cosine law可以得到可以吸收多少能量.</p><h3 id="Lambertian-Diffuse-Shading"><a href="#Lambertian-Diffuse-Shading" class="headerlink" title="Lambertian (Diffuse) Shading"></a>Lambertian (Diffuse) Shading</h3><p><img src="https://i.niupic.com/images/2020/05/26/85hC.png" alt=""><br>对于shading point为什么会有颜色?吸收一部分能量,散射出去不要的能量,kd则代表了点本身吸收能量的比值(0白1黑),当kd定义成三通道,我们就可以表述漫反射的颜色啦<br>漫反射是均匀反射到不同方向去,所以和观测方向独立无关<br><img src="https://i.niupic.com/images/2020/05/27/862t.png" alt=""></p><h1 id="08-Shading-2-Shading-Pipeline-and-Texture-Mapping"><a href="#08-Shading-2-Shading-Pipeline-and-Texture-Mapping" class="headerlink" title="08-Shading 2(Shading,Pipeline and Texture Mapping)"></a>08-Shading 2(Shading,Pipeline and Texture Mapping)</h1><p>我们的Blinn-Phong反射模型中上节课已经讲到了在一个shading point上的漫反射了.</p><h2 id="Shading-Cont"><a href="#Shading-Cont" class="headerlink" title="Shading Cont."></a>Shading Cont.</h2><h3 id="Specular-Term"><a href="#Specular-Term" class="headerlink" title="Specular Term"></a>Specular Term</h3><p><strong>Intensity depends on view direction</strong><br>什么时候可以看到高光呢?<br>我们的观察方向和镜面反射方向足够接近时.<br><img src="https://i.niupic.com/images/2020/05/27/861R.png" alt=""><br>在Blinn-Phong模型中,我们利用了一个很妙的想法</p><blockquote><p>视角和镜面反射方向接近时,半程向量(half vector)和法线方向接近,所以我们可以做如下判断<br><img src="https://i.niupic.com/images/2020/05/27/861U.png" alt=""><br>我们只需要看半程向量和法线是否接近,用点乘(接近1近,0远)<br>我们简化了,没有考虑光的吸收(blinn-phong模型)<br>参数Ks一般是白色(高光)<br>在max后增加了一个指数p,因为当我们用cosα作为高光判断时容忍度太高了,当相差度数挺远也会产生高光,因此我们加上指数项来限制高光范围.一般来说我们p要取到100以上<br><img src="https://i.niupic.com/images/2020/05/27/862n.png" alt=""></p></blockquote><h3 id="Ambient-Team"><a href="#Ambient-Team" class="headerlink" title="Ambient Team"></a>Ambient Team</h3><p>做一个大胆假设,任何一个点接受环境的光都是相同的,同时又有自己的颜色<br><img src="https://i.niupic.com/images/2020/05/27/862I.png" alt=""><br>和光照方向无关,和观测方向也没有关系,所以其实是一个常数→保证没有一个地方完全是黑的<br>当然这是一个巨大胆的假设,真实情况我们在后来的全局光照会进一步说明.</p><h3 id="Blinn-Phong-Reflection-Model"><a href="#Blinn-Phong-Reflection-Model" class="headerlink" title="Blinn-Phong Reflection Model"></a>Blinn-Phong Reflection Model</h3><p><img src="https://i.niupic.com/images/2020/05/27/8631.png" alt=""><br>我们对场景内所有的点做着色即可.<br>我们可以看出来blinn-phong模型其实是高度简化的,比如物体的凹凸程度</p><p>以上步骤中与观察点和物体间的距离无关,后面会解释.(radiance)</p><h3 id="Shading-Frequencies"><a href="#Shading-Frequencies" class="headerlink" title="Shading Frequencies"></a>Shading Frequencies</h3><p>着色频率(面/顶点/每一个像素)</p><h4 id="Flat-shading-triangle"><a href="#Flat-shading-triangle" class="headerlink" title="Flat shading(triangle)"></a>Flat shading(triangle)</h4><p>求出三角形的法线(两边叉积),然后与视角方向/光线计算,可以看出效果不太好,不太能处理平滑部分</p><h4 id="Gouraud-shading-vertex"><a href="#Gouraud-shading-vertex" class="headerlink" title="Gouraud shading(vertex)"></a>Gouraud shading(vertex)</h4><p>先假设顶点的法线能求,每个顶点进行着色,然后三个顶点组成的三角形内部用插值来做.</p><h4 id="Phong-shading-pixel"><a href="#Phong-shading-pixel" class="headerlink" title="Phong shading(pixel)"></a>Phong shading(pixel)</h4><p>逐像素进行shading,然后三角形间做插值</p><h4 id="着色频率和面的频率也有关系"><a href="#着色频率和面的频率也有关系" class="headerlink" title="着色频率和面的频率也有关系"></a>着色频率和面的频率也有关系</h4><p>我们模型足够复杂的时候,逐面/顶点效果不一定比逐像素差;当三角形个数超过像素数时,逐像素的计算量说不定还会更小<br><img src="https://i.niupic.com/images/2020/05/27/864g.png" alt=""></p><h4 id="我们怎么知道逐顶点-像素的法线方向"><a href="#我们怎么知道逐顶点-像素的法线方向" class="headerlink" title="我们怎么知道逐顶点/像素的法线方向?"></a>我们怎么知道逐顶点/像素的法线方向?</h4><blockquote><p>逐顶点:<br>最好的方式当然是我们已经知道了其本身想表达的几何体的形状再做法线;当然没这么好的事.<br>做一个简化,我们推测一个顶点的法线可以通过其周围的三角形的法线进行加权平均(简化的话可以用简单平均)<br><img src="https://i.niupic.com/images/2020/05/27/8658.png" alt=""></p></blockquote><blockquote><p>逐像素:<br>求出顶点的法线方向,然后用重心坐标插值Barycentric interpolation)来求得,最后标准化<br><img src="https://i.niupic.com/images/2020/05/27/865v.png" alt=""></p></blockquote><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>所有的东西结合起来称为管线,从最初到最后我们经历了什么过程?Real-time Rendering pipeline表示一系列操作<br>下图就是从三维场景到渲染出二维图像的操作,这个操作在硬件里已经写好了↓<br><img src="https://i.niupic.com/images/2020/05/27/866I.png" alt=""><br>空间的点→屏幕空间上的点→屏幕空间三角形→像素(不同部分)→着色好的像素→输出的图片</p><ul><li>MVP transforms–Vertex Processing</li><li>Smapling triangle coverage–Rasterization</li><li>Z-Buffer Visiblity Tests–Fragment Processing</li><li>Shading–Vertex Processing/Fragment Processing(这里看着色频率)</li><li>Texture mapping–Vertex Processing/Fragment Processing</li></ul><h3 id="Shader-Programs"><a href="#Shader-Programs" class="headerlink" title="Shader Programs"></a>Shader Programs</h3><p>描述单一顶点/像素执行的操作,操作会对所有顶点/像素执行操作.<br>对于像素着色器,我们要告诉这个像素最后的颜色是什么.</p><pre><code>//Example:GLSL fragment shader program(OpenGL)uniform sampler2D myTexture;//纹理uniform vec3 lightDir;//光照固定//全局变量varying vec2 uv;//插值varying vec3 norm;//插值出任何一个法线void diffuseShader(){    vec3 kd; //漫反射系数    kd = texture2d(myTexture,uv);//material color from texture    kd *= clamp(dot(-lightDir,norm),0.0,1.0); //光负方向输入,简化版本未使用I/r²    gl_FragColor = vec4(kd,1.0);//输出像素}//定义任一顶点/像素该如何操作</code></pre><p><a href="http://shadertoy.com/view/ld3Gz2" target="_blank" rel="noopener">Snail Shader Program</a><br>忽略OpenGL只去写Shader就可以的OL项目.</p><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>我们希望得到一个三角形,三角形内部是什么亚子的?<br>对于一个物体,着色模型是一样的,不过不同地方颜色不同→物体不同位置漫反射系数不同.</p><h3 id="Surfaces-are-2D"><a href="#Surfaces-are-2D" class="headerlink" title="Surfaces are 2D"></a>Surfaces are 2D</h3><p>3D物体的表面是2D的,对于3D表面上任意一个点可以找到2D图像中对应的一个点(texture)<br>我们要解决的问题就是怎么把3D空间中的三角形映射到2D空间上呢?<br>one.美工加班 two.自动化parameterazition(参数化)<br>总之我们不管哈哈哈哈哈哈哈</p><h3 id="Vsiualization-of-Texture-Coordinates"><a href="#Vsiualization-of-Texture-Coordinates" class="headerlink" title="Vsiualization of Texture Coordinates"></a>Vsiualization of Texture Coordinates</h3><p>纹理上也应该有对应的坐标系(uv)<br>对于纹理来说,u<del>(0,1)v</del>(0,1)<br>纹理可以重复使用多次!(tiled textures)Wang Tiling</p><h1 id="09-Shading-3-Texture-Mapping-Cont"><a href="#09-Shading-3-Texture-Mapping-Cont" class="headerlink" title="09-Shading 3(Texture Mapping Cont.)"></a>09-Shading 3(Texture Mapping Cont.)</h1><h2 id="Shading-Cont-1"><a href="#Shading-Cont-1" class="headerlink" title="Shading Cont."></a>Shading Cont.</h2><h3 id="Barycentric-coordinates"><a href="#Barycentric-coordinates" class="headerlink" title="Barycentric coordinates"></a>Barycentric coordinates</h3><p>在三角形内部进行插值→Why?<br>我们得到了顶点的属性,我们希望三角形内平滑的过渡<br>我们希望插入什么内容?<br>Texture coordinates材质坐标, colors颜色 , 法线向量<br>怎么做插值?<br>重心坐标(用(α,β,γ)来表示一个点)<br><img src="https://i.niupic.com/images/2020/05/27/86jH.png" alt=""><br>用三角形三个顶点的坐标来表示三角形内部的点(顶点坐标怎么表示就无所谓了)<br>在三角形内部是α β γ均非负<br>我们计算重心坐标可以借助三角形面积比<br><img src="https://i.niupic.com/images/2020/05/27/86jZ.png" alt=""><br>三角形自身的重心的重心坐标(α,β,γ)=(1/3,1/3,1/3)<br>当然在直角坐标系中我们有直接计算的公式<br><img src="https://i.niupic.com/images/2020/05/27/86k6.png" alt=""></p><p>得到重心坐标后,我们便可以通过重心坐标进行插值:<br>对于已知三个顶点的属性,我们线性组合利用重心坐标就可以得到内部的属性值<br><img src="https://i.niupic.com/images/2020/05/27/86ke.png" alt=""><br>我们要注意到,就是在投影变换下不能保持重心坐标不变.<br>如果想插值三维中的属性,那么利用三维中的坐标进行重心坐标线性变换<br>例如之前提到的深度插值,我们就应该直接在三维空间中做插值再对应到二维结果中.</p><h2 id="Texture-queries"><a href="#Texture-queries" class="headerlink" title="Texture queries"></a>Texture queries</h2><h3 id="Texture-Mapping-Diffuse-Color"><a href="#Texture-Mapping-Diffuse-Color" class="headerlink" title="Texture Mapping:Diffuse Color"></a>Texture Mapping:Diffuse Color</h3><p>Simple Way:</p><pre><code>for each rasterized screen sample (x,y):    (u,v)=evaluate texture coordinate at (x,y);//使用重心坐标    texcolor=texture.sample(u,v);    set sample&apos;s color to texcolor;//漫反射系数  </code></pre><h3 id="Texture-Magnification-TOO-SMALL"><a href="#Texture-Magnification-TOO-SMALL" class="headerlink" title="Texture Magnification-TOO SMALL"></a>Texture Magnification-TOO SMALL</h3><p>如果我们的纹理太小了怎么办?高清的模型/低清的材质<br>我们去找到材质上的pixel–我们称为texel(纹理元素),那么当给出的坐标不是整数的时候我们采取一下几种方法:</p><ol><li>Nearest:直接找最近的–形成一块一块的</li><li>Bilinear interpolation: 双线性插值<br><img src="https://i.niupic.com/images/2020/05/27/86le.png" alt=""><br>水平两次差值+竖直一次插值</li><li>Bicubic:双三次插值→取周围的16个,四个一组做差值,再做插值.<h3 id="Texture-Magnification-TOO-LARGE"><a href="#Texture-Magnification-TOO-LARGE" class="headerlink" title="Texture Magnification-TOO LARGE"></a>Texture Magnification-TOO LARGE</h3><img src="https://i.niupic.com/images/2020/05/27/86pS.png" alt=""><br>一个像素覆盖纹理贴图的区域是不同的,近覆盖小远覆盖多<br>Antialiasing-一个像素内包含多个纹理值,频率很高,但只用一个像素进行采样,必然会导致走样现象<br>自然而然我们想到超采样方法,但是太昂贵了</li></ol><p><em>我们进行另外一条方式,如果我们不采样呢?我们想得到一个区域的值的平均</em><br>too small中Point Query(点查询)VStoo large中Range Query(面查询,且这里我们是avg.)</p><p><strong><em>Mipmao</em></strong>允许我们进行范围查询(Fast(快速),Approx.(近似),Square(近似正方形的))<br>Mip meaning a multitude in a small space<br><img src="https://i.niupic.com/images/2020/05/27/86qn.png" alt=""><br>额外存储1/3原图的存储量(1/4+1/16+1/64+…)<br><img src="https://i.niupic.com/images/2020/05/27/86qt.png" alt=""><br>这样我们可以得到原图压缩1 2 3 …次后的图像<br><img src="https://i.niupic.com/images/2020/05/27/86qG.png" alt=""><br><img src="https://i.niupic.com/images/2020/05/27/86qN.png" alt=""><br>我们通过把屏幕上的像素点映射到纹理空间后,通过计算就可以得到应该在D=?级进行面查询了,D重要!设想当正方形边长L=4,那么对应mipmap中第二层对应的纹理图<br>近用底层,远用顶层,但是现在因为层数是离散的,所以会显示不连续–需要插值!</p><p>Trilinear Interpolation<br><img src="https://i.niupic.com/images/2020/05/27/86r6.png" alt=""><br>两个层分别做双线性插值(),在层与层之间(D是离散的)再进行插值<br>→三线性插值<br>但是Mipmap会产生远处过于模糊的现象<br>仅仅用一个正方形进行框定.<br><img src="https://i.niupic.com/images/2020/05/27/86so.png" alt=""></p><blockquote><p>为了解决这个问题→各项异性过滤(Anisotropic Filtering)→比起mipmap多了一些水平、竖直方向的图像(ripmap),从而并不是单单用一个正方形来进行框定<br>2x就是竖直压缩一次,4x就是压缩两次,最后收敛到3倍,应用各项异性过滤显存够用的时候开到最高就行了:)<br>解决了矩形部分的查询<br>总共的开销变成了原来的三倍</p></blockquote><p>更加不规则的??EWA 比如那个斜着的?还有更多过滤办法233<br>!()[<a href="https://i.niupic.com/images/2020/05/27/86ss.png]" target="_blank" rel="noopener">https://i.niupic.com/images/2020/05/27/86ss.png]</a><br>比如EWA过滤,任意不规律的形状,可以拆成不同的圆形,多次查询</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> lessons </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗德里德斯旋转公式</title>
      <link href="/rodrigues.html"/>
      <url>/rodrigues.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>本文是计算机图形学中罗德里德斯旋转公式的证明</p></blockquote><a id="more"></a><p><img src="https://pic.downk.cc/item/5ecbf8f6c2a9a83be5f10998.jpg" alt=""><br><img src="https://pic.downk.cc/item/5ecbf903c2a9a83be5f11a7a.jpg" alt=""></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 证明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> proof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代计算机图形学入门04-06</title>
      <link href="/graphics2.html"/>
      <url>/graphics2.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>GAMES101-现代计算机图形学入门 Lecture 04-06</p></blockquote><a id="more"></a><h1 id="04-Transformation-Cont"><a href="#04-Transformation-Cont" class="headerlink" title="04-Transformation Cont"></a>04-Transformation Cont</h1><h2 id="3D-transformations"><a href="#3D-transformations" class="headerlink" title="3D transformations"></a>3D transformations</h2><ul><li>Linear map和translation基本都没啥大变化</li><li>需要注意的是旋转<br><img src="https://pic.downk.cc/item/5eca952bc2a9a83be5491ac7.png" alt=""><br>注意到对x/z旋转正常,对y旋转的符号问题 - z叉乘x得到y 观测是从z轴→x轴,但是矩阵对应x轴→z轴 故需要取转置/逆矩阵</li><li>Compose any 3D rotation from Rx Ry Rz <strong>euler angle</strong><br><img src="https://pic.downk.cc/item/5eca9690c2a9a83be54b1e81.png" alt=""></li><li>Rodrigues’ Rotation Formula 罗德里德斯旋转公式<br>定义了旋转角度 α 沿 <em>n</em> 轴方向旋转(我们默认旋转时起点在原点上),(n是单位向量)<br><img src="https://pic.downk.cc/item/5ecb2748c2a9a83be5d48740.png" alt=""> #证明另见</li><li>补充四元数:旋转角度的差值问题</li></ul><h2 id="Viewing-transformation"><a href="#Viewing-transformation" class="headerlink" title="Viewing transformation"></a>Viewing transformation</h2><h3 id="View-Camera-transformation"><a href="#View-Camera-transformation" class="headerlink" title="View/Camera transformation"></a>View/Camera transformation</h3><p>视图变换</p><h4 id="what-is-view-transformation"><a href="#what-is-view-transformation" class="headerlink" title="what is view transformation?"></a>what is view transformation?</h4><p>** how to take a photo?**</p><ul><li>先找一个好地方,把人安排好 model transformation</li><li>找到一个好角度,放置相机 view transformation</li><li>拍照~ projection transformation</li><li>简称MVP变换<h4 id="how-to-perform-view-transformation"><a href="#how-to-perform-view-transformation" class="headerlink" title="how to perform view transformation"></a>how to perform view transformation</h4>先定义相机</li><li>位置</li><li>看向的方向</li><li>相机的上方方向(防止旋转)<br>当相机和所有的物体一起移动,那么照片会一直一样</li></ul><p><strong>我们把相机永远放在原点,并且看向-z方向,上方向是Y(约定俗成)</strong><br><strong>实际我们是将所有物体相对相机移动</strong></p><h4 id="Transform-matrix"><a href="#Transform-matrix" class="headerlink" title="Transform matrix"></a>Transform matrix</h4><p>位置移到原点<br>看向方向旋转到-z<br>向上方向旋转到y<br>同时看向方向和向上方向的叉乘到x<br>数学表示<br><img src="https://pic.downk.cc/item/5ecb2c2bc2a9a83be5d8163d.png" alt=""></p><ul><li>先用坐标轴到目标方向进行表示比较容易理解,先求简单问题再求逆</li><li>相机如此变换,其他物体也都需要这样变换</li></ul><p><strong>所以我们实际是对物体和相机一同变换,变换形式是一样的,所以又叫ModelView Transformation</strong><br>接下来我们接觉 投影变化</p><h3 id="Projection-transformation"><a href="#Projection-transformation" class="headerlink" title="Projection transformation"></a>Projection transformation</h3><p>3D to 2D</p><blockquote><p>正交投影→工程制图 本质→不会带来近大远小现象<br>透视投影→人眼 平行线不再平行 会相交 本质→会近大远小</p></blockquote><p><img src="https://pic.downk.cc/item/5ecb309ec2a9a83be5dc7b0d.png" alt=""><br>把透视投影中相机拉到无限远→正交投影</p><h4 id="Orthographic-projection"><a href="#Orthographic-projection" class="headerlink" title="Orthographic projection"></a>Orthographic projection</h4><p><strong>一种简单的理解方式</strong>:</p><ul><li>相机扔到原点,看向-z,向上y</li><li>直接丢到 z 坐标</li><li>平移并缩放至 [-1,1]² 约定俗成</li></ul><p><strong>General的方式</strong></p><ul><li>对于任意一个长方体(cuboid)映射到一个[-1,1]³正则正方体(canonical)上</li><li>上述变化通过平移缩放实现</li><li>We want to map a cuboid [l, r] x [b, t] x [f, n] to the “canonical (正则、规范、标准)” cube [-1, 1]³</li><li>注意这里f是远,n是近,远z值小,近z值大(因为是向-z看去)<br><img src="https://pic.downk.cc/item/5ecb339ec2a9a83be5e0faa3.png" alt=""></li><li>会拉伸,后面会再进行处理回去,我们这里做的是正则标准化处理</li></ul><h4 id="Perspective-projection"><a href="#Perspective-projection" class="headerlink" title="Perspective projection"></a>Perspective projection</h4><p>在计算机图形学中应用最广泛<br>近大远小,平行线不再平行,会交于一点<br>(欧式几何是在同一平面内,而我们则是涉及到不同的平面和角度)</p><ul><li>回忆homogeneous coordinates</li><li>(x,y,z,1),(kx,ky,kz,k!=0),(xz,yz,z²,z!=0)都可以代表3D平面内同一个点(x,y,z)</li><li>将锥体的远平面挤成正则立方体,然后做正交投影(已知)<ul><li>近平面上的点永远不变</li><li>z 不变</li><li>远平面的中心点不发生变化</li><li>远平面挤压过后z大小会变成近平面处大小,故我们可以进行相似三角形处理,x’和y’得到的方式一样</li><li><img src="https://pic.downk.cc/item/5ecb3ba9c2a9a83be5ee06bf.png" alt=""></li><li><img src="https://pic.downk.cc/item/5ecb3bbcc2a9a83be5ee1d12.png" alt=""><br>关键点来了,我们的变换目标在齐次坐标系中如下<br><img src="https://pic.downk.cc/item/5ecb3c30c2a9a83be5eed114.png" alt=""><br>即我们的原向量经过变换后变为现在的向量,所以可以我们的压缩矩阵便可解出一部分了<br><img src="https://pic.downk.cc/item/5ecb3d1cc2a9a83be5f013e9.png" alt=""><br>根据我们之前的观察:近平面上的点变换后不变.远平面的z都不变化</li></ul></li></ul><ol><li>近平面上点<br><img src="https://pic.downk.cc/item/5ecb3eaac2a9a83be5f24ef3.png" alt=""></li><li>远平面上的中心点<br><img src="https://pic.downk.cc/item/5ecb3eb8c2a9a83be5f266ee.png" alt=""><br>可以解得<br>A = n + f<br>B = -nf<br>至此我们便得到了挤压矩阵,再乘以正交矩阵便可以得到透视矩阵了<br><img src="https://pic.downk.cc/item/5ecb4a7dc2a9a83be5052258.png" alt=""></li></ol><h1 id="05-Rasterization-1-Triangles"><a href="#05-Rasterization-1-Triangles" class="headerlink" title="05-Rasterization 1(Triangles)"></a>05-Rasterization 1(Triangles)</h1><h2 id="Finishing-up-Viewing"><a href="#Finishing-up-Viewing" class="headerlink" title="Finishing up Viewing"></a>Finishing up Viewing</h2><h3 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h3><p>在上一个透视投影中,我们已经讲到了要压缩成和近平面一样的长宽,那么近平面长宽是什么呢?<br>如果特殊指出来了,很好,但是如果没有,我们可以用fovY(field-of-view)和aspect ratio来共同定义.<br><img src="https://pic.downk.cc/item/5ecb62d1c2a9a83be52e096f.png" alt=""><br>那么我们就可以从fovY转换到近平面的长宽了<br><img src="https://pic.downk.cc/item/5ecb636cc2a9a83be52ee3bb.png" alt=""><br>由上我们便可以定义一个视锥</p><h3 id="what’s-after-MVP"><a href="#what’s-after-MVP" class="headerlink" title="what’s after MVP"></a>what’s after MVP</h3><p>得到了canonical cube后我们要把它画在屏幕上</p><ul><li>what is a screen<ul><li>一个像素的数组</li><li>数组的大小:分辨率 表示像素多少</li><li>一种典型的光栅显示设备</li><li>rasterize == drawing onto the screen</li><li>pixel:我们目前认为它是一个个不同颜色的小方块/颜色是由RGB混合</li><li>屏幕空间:像素坐标(0,0)到(width-1,height-1);像素(x,y)的中心位于(x+0.5,y+0.5)则屏幕空间为(0,0)到(width,height)</li></ul></li><li>Canonical cube to screen<ul><li>此处与z无关</li><li>(x,y)由[-1,1]²到[0,width]*[0,height]</li><li>Viewport transform matrix 视口变换:<br><img src="https://pic.downk.cc/item/5ecb674bc2a9a83be5346ed9.png" alt=""></li><li>可以看到是长宽做了scaling 然后平移中心(我们定义屏幕左下角为坐标原点所以中心要移)</li></ul></li></ul><h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>Drawing to raster displays</p><h3 id="Triangle-Meshes"><a href="#Triangle-Meshes" class="headerlink" title="Triangle Meshes"></a>Triangle Meshes</h3><ul><li>三角形是最基本的多边形,任何其他的多边形都可以拆成三角形</li><li>三角形内部一定是同一平面的</li><li>三角形内外部定义良好(向量叉积还可以判断内外)</li><li>三角形定义好三点后,可以定义一个渐变(插值)方法</li></ul><p>那么我们怎么用像素值来大体表示三角形呢?<br>Key concept:判断像素中心点与三角形位置关系</p><blockquote><p>A simple approach: Sampling(采样)<br>采样就是把一个函数离散化的过程<br>采样是图形学中核心观念,我们可以用1D(time)2D(area,direction)3D(volume)进行采样</p></blockquote><p>Define Binary Function:inside(tri,x,y)<br><img src="https://pic.downk.cc/item/5ecb7435c2a9a83be548f9e8.png" alt=""></p><pre><code>for(int x = 0 ; x &lt; xmax; ++x )  for(int y = 0; y &lt; ymax; ++y)    image[x][y] = inside(tri,x + 0.5,y + 0.5);</code></pre><p>那么怎么判断是否在内部呢?<br><strong>使用三次向量叉乘</strong></p><p>Edge Cases:当采样点正好在两个三角形边界位置怎么处理?(自己定义一个标准)</p><p>加速条件:<br>考虑一个三角形光栅化时,按上述代码,我们要扫描整个屏幕,实际没必要.我们可以使用包围盒(Bounding Box)<br><img src="https://pic.downk.cc/item/5ecb768fc2a9a83be54c915e.png" alt=""><br>上图便是一个轴向的包围盒,也可叫做axies-aligned bounding box(AABB)</p><p>Incremental Triangle Traversal<br><img src="https://pic.downk.cc/item/5ecb7762c2a9a83be54dca52.png" alt=""><br>对于瘦长又旋转的三角形,我们可以用上图方法进行处理(但可能不好做?具体问题具体分析叭!)</p><p><strong><em>Summary 我们就是用过采样Inside函数,得到光栅化.就是每个可能像素检测是否在三角形内</em></strong></p><h3 id="Rasterization-on-Real-Displays"><a href="#Rasterization-on-Real-Displays" class="headerlink" title="Rasterization on Real Displays"></a>Rasterization on Real Displays</h3><p>实际上pixel并不是一个个小方块;事实上人眼对于绿色的感知更敏感,所以可能绿色会更多一些<br>打印: 省墨水/颜色越多越黑/减色系统 屏幕RGB越高越白</p><p>当我们已经把采样信号发往显示器了,然后捏?<br>锯齿问题非常严重!(Jaggies)采样率不够高,从而产生走样现象(Aliasing)<br>所以我们的一个重要目标就是抗锯齿.</p><h1 id="06-Rasterization-2-Antialiasing-and-Z-Buffering"><a href="#06-Rasterization-2-Antialiasing-and-Z-Buffering" class="headerlink" title="06-Rasterization 2(Antialiasing and Z-Buffering)"></a>06-Rasterization 2(Antialiasing and Z-Buffering)</h1><h2 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h2><p>锯齿/走样→抗锯齿/反走样</p><h3 id="sampling-artifacts"><a href="#sampling-artifacts" class="headerlink" title="sampling artifacts"></a>sampling artifacts</h3><p>采样是图形学中广泛的方法<br>但会产生Artifacts(Erros/Mistakes/Inaccuracies)</p><ol><li>Jaggies 锯齿</li><li>Moire 摩尔纹 Skip odd rows and columns隔行采样</li><li>Wagon wheel effect 轮子倒转 在时间采样上出现问题</li></ol><p><strong>本质:信号变换速度过快(high frequency)而采样速度过慢</strong></p><h3 id="Antialiasing-Idea-Blurring-pre-filtering-before-sampling"><a href="#Antialiasing-Idea-Blurring-pre-filtering-before-sampling" class="headerlink" title="Antialiasing Idea:Blurring(pre-filtering) before sampling"></a>Antialiasing Idea:Blurring(pre-filtering) before sampling</h3><p>在采样前进行滤波(模糊操作),再进行采样,便可以达成抗锯齿的效果<br>(模糊之后,采样该什么颜色就用什么颜色)<br>采样之后再进行模糊→Blurred Aliasing达不到效果</p><h3 id="Frequency-Domain"><a href="#Frequency-Domain" class="headerlink" title="Frequency Domain"></a>Frequency Domain</h3><p><strong>Frequency Domain 频域</strong><br>频率 cos(2πf x) f = 1/T<br>傅里叶级数展开:任何一个周期函数都可以写成一系列正余弦线性组合和一个常数项的和,(eg用不同正余弦去逼近矩形波)<br>傅里叶变换:将信号变换为频率/逆傅里叶变换:频率变换为信号<br><img src="https://pic.downk.cc/item/5ecb8b85c2a9a83be56b7b54.png" alt=""><br>实质就是把函数变成不同频率段并把频率段显示出来<br>当频率变高之后,我们就很不容易用采样将原来的函数恢复出来<br><img src="https://pic.downk.cc/item/5ecb8c5dc2a9a83be56ca71e.png" alt=""><br><img src="https://pic.downk.cc/item/5ecb8c6bc2a9a83be56cbecf.png" alt=""><br>两种频率截然不同,但是采样频率给定时,获得同样的信息,也就是走样.</p><h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><p>滤波:去掉一些特定的频率内容<br>对图像进行傅里叶变换→时域变换到频域<br><img src="https://pic.downk.cc/item/5ecb8edcc2a9a83be570374b.png" alt=""><br>中间是低频信息,四周是高频信息,而亮度则代表了包含信息的多少<br>对于真实图片,大部分的信息都集中在低频部分</p><blockquote><p>水平和竖直的线: 分析信号时会默认为周期性信号,那么对于不周期信号来说,比如这张图,我们认为到了图的右边界后又从图的左边界进入;上下边界同理;即我们叠了好多好多张图.正常情况下图的左右边界信号会产生剧烈变化,也就会产生高频.</p></blockquote><p>傅里叶变换可以让我们看到信号的频率分布!<br>我们使用<strong>高通滤波</strong>,可以看到只保留了图像的边界(灰度发生剧烈变化的地方)<br><img src="https://pic.downk.cc/item/5ecb90c5c2a9a83be572846f.png" alt=""><br>我们使用<strong>低通滤波</strong>,可以看到图像变得十分模糊,细节全部去除<br><img src="https://pic.downk.cc/item/5ecb9143c2a9a83be573317a.png" alt=""><br>下面我们再进行把高通和低通都滤掉<br><img src="https://pic.downk.cc/item/5ecb9244c2a9a83be5743c40.png" alt=""><br><img src="https://pic.downk.cc/item/5ecb924bc2a9a83be57443cb.png" alt=""><br>更多知识去学习数字图像处理;但是现在更多是用机器学习来做处理</p><h3 id="Filtering-Averaging-Convolution"><a href="#Filtering-Averaging-Convolution" class="headerlink" title="Filtering = Averaging = Convolution"></a>Filtering = Averaging = Convolution</h3><p>卷积窗口blahblahblah 窗口和信号重叠部分做点乘作为结果,形式上就是加权取平均<br><strong>Convolution Theorem</strong><br>Convolution in the spatial domain is equal to multiplication in the frequency domain,and vice versa.<br>时域上想对两个信号进行卷积,就和两个信号频域上的乘积相等(另一半时域相乘就是频域卷积)<br>我们可以直接:</p><ol><li>直接在时域进行卷积</li><li>频域变换<ul><li>将图和卷积滤波器傅里叶变换到频域</li><li>频域上频谱相乘</li><li>逆傅里叶变换变换回时域<br><img src="https://pic.downk.cc/item/5ecb9799c2a9a83be57b06d1.png" alt=""><br>上面使用的是Box Filter 盒子变大→频率上变小,提取更低频的信号</li></ul></li></ol><h3 id="Sampling-Repeating-grequency-contents"><a href="#Sampling-Repeating-grequency-contents" class="headerlink" title="Sampling = Repeating grequency contents"></a>Sampling = Repeating grequency contents</h3><p>冲激函数,只在固定时间有值,其余位置无值<br><img src="https://pic.downk.cc/item/5ecb9991c2a9a83be57d6cf4.png" alt=""><br>↑时域上的乘积,是频域上的卷积</p><h3 id="Aliasing-Mixed-Frequency-Contents"><a href="#Aliasing-Mixed-Frequency-Contents" class="headerlink" title="Aliasing = Mixed Frequency Contents"></a>Aliasing = Mixed Frequency Contents</h3><p><img src="https://pic.downk.cc/item/5ecb9a1fc2a9a83be57dfa76.png" alt=""><br>采样不够快,冲激函数在频域内的间隔是时域中的倒数,那么频域的间隔会变小;频谱发生了混叠→Artifacts</p><h3 id="how-to-reduce-aliasing-error"><a href="#how-to-reduce-aliasing-error" class="headerlink" title="how to reduce aliasing error"></a>how to reduce aliasing error</h3><ol><li>提高采样率,那么频谱自然不混叠,但是这就要求更高分辨率的显示设备,受限于物理限制,(<del>分辨率1024K肯定看不出来锯齿了ovo</del></li><li>Antialiasing 先模糊后采样, 先低通滤波截取高频信号, 然后就使频谱不再混叠.Limiting,then repeating.<br><img src="https://pic.downk.cc/item/5ecb9c99c2a9a83be580a0cd.png" alt=""><br>常规的采样中,我们的像素值非A即B;而进行反走样操作后,我们的像素值会取中间值<h3 id="Practical-Pre-Filter"><a href="#Practical-Pre-Filter" class="headerlink" title="Practical Pre-Filter"></a>Practical Pre-Filter</h3>取一个像素宽度的box filter,起到低通(模糊)操作.<br>先卷积再采样.<br>对于任何一个覆盖像素内部,我们都根据三角形覆盖其中的面积做卷积,得到不同大小的像素值.<br>但是面积很难进行计算,所以我们下面将采取一种近似方法进行处理<h3 id="Antialiasing-by-supersampling-MSAA-multi-sampled-antialising"><a href="#Antialiasing-by-supersampling-MSAA-multi-sampled-antialising" class="headerlink" title="Antialiasing by supersampling(MSAA = multi-sampled antialising)"></a>Antialiasing by supersampling(MSAA = multi-sampled antialising)</h3>我们认为上面的一个像素内部又进行划分,划分为4个小的像素,然后分别用这4个小像素进行计算取平均(2x2 MSAA)<br><img src="https://pic.downk.cc/item/5ecb9fb4c2a9a83be5840ea7.png" alt=""><br><img src="https://pic.downk.cc/item/5ecb9fbdc2a9a83be58416c0.png" alt=""><br><img src="https://pic.downk.cc/item/5ecb9fc5c2a9a83be5841da1.png" alt=""><br><img src="https://pic.downk.cc/item/5ecb9fccc2a9a83be5842541.png" alt=""><br><img src="https://pic.downk.cc/item/5ecb9fd6c2a9a83be5842f49.png" alt=""><br><img src="https://pic.downk.cc/item/5ecb9fe0c2a9a83be584370b.png" alt=""><br>完成这一步相当于我们进行了上述模糊的操作(得到一个近似的三角形覆盖率),然后再进行采样就能起到抗锯齿的作用(其实已经隐含在上一步了)</li></ol><h3 id="Antialiasing-Today"><a href="#Antialiasing-Today" class="headerlink" title="Antialiasing Today"></a>Antialiasing Today</h3><ul><li>No free lunch!</li><li>我们做MSAA用更多的点进行测试,增大了很多计算量(2x2=4)</li><li>其实工业界中像素分布不均匀,而且样本会进行复用,样本怎样分布会影响性能,所以实际多重采样并不是线性增大计算量\<blockquote><p>抗锯齿方案里程碑:<br>FXAA(Fast Approximate AA)非增加采样,是先得到有锯齿的图,然后把锯齿消除,消除的方法是用没有锯齿的边界进行替换(注意前面说过不能先Sampling再Filter)<br>TAA(Tem’poral AA)近几年兴起,与时间相关.找上一帧的信息.在静止场景内,我们可以用一个像素内不同位置的点来感知是否在三角形内.在时间范围内,我们复用上一步感知得到的的结果并应用进来</p></blockquote></li><li>Super resolution / super sampling<ul><li>from low resolution to high resolution</li><li>与反走样不是一回事但是本质相同,实际上还是样本不足</li><li>DLSS:Deep Learning Super Sampling 用深度学习猜测局部细节问题</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> lessons </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代计算机图形学入门01-03</title>
      <link href="/graphics1.html"/>
      <url>/graphics1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>GAMES101-现代计算机图形学入门 Lecture 01-03</p></blockquote><a id="more"></a><h1 id="01-Overview-of-Computer-Graphics"><a href="#01-Overview-of-Computer-Graphics" class="headerlink" title="01-Overview of Computer Graphics"></a>01-Overview of Computer Graphics</h1><h2 id="what-is-computer-graphics"><a href="#what-is-computer-graphics" class="headerlink" title="what is computer graphics"></a>what is computer graphics</h2><h2 id="why-study-computer-graphics"><a href="#why-study-computer-graphics" class="headerlink" title="why study computer graphics"></a>why study computer graphics</h2><ul><li>好的画面?画面是否足够亮:渲染技术的全局光照</li><li>Spicial effect:最简单的应用,特殊效果.</li><li>真实/仿真:难!</li><li>Animations:毛发数量多/光线和毛发交互?几何表述/渲染/计算光线</li><li>Design:CAD CG-PHOTO</li><li>Visualization 可视化 近年独立</li><li>Virtual Reality</li><li>Digital Illustration</li><li>Simulation</li><li>Graphical User Interfaces:GUI 今年独立</li><li>Typography 字体设计部分</li></ul><p><strong>fundamental intellectual/technical challenges</strong></p><h2 id="course-topics"><a href="#course-topics" class="headerlink" title="course topics"></a>course topics</h2><ol><li>rasterization 光栅化 OpenGL 实时将三维投影到二维/30fps</li><li>cuves and meshes 曲线/曲面 怎么表示?</li><li>ray tracing 光线追踪</li><li>animation/simulation 动画/模拟</li></ol><p>Course NOT ABOUT<br>using OPENGL/DirectX/Vulcan-API 3D modeling using Maya/unity/unreal engine computer vision/deep learning</p><h2 id="course-logistics"><a href="#course-logistics" class="headerlink" title="course logistics"></a>course logistics</h2><p>assignments <a href="http://www.smartchair.org/GAMES2020Course-YLQ/" target="_blank" rel="noopener">http://www.smartchair.org/GAMES2020Course-YLQ/</a><br>Use An IDE- VS / VS Code</p><h1 id="02-Review-of-Linear-Algebra"><a href="#02-Review-of-Linear-Algebra" class="headerlink" title="02-Review of Linear Algebra"></a>02-Review of Linear Algebra</h1><h2 id="graphics’-dependencies"><a href="#graphics’-dependencies" class="headerlink" title="graphics’ dependencies"></a>graphics’ dependencies</h2><ul><li>basic mathematics- linear algebra, calculus, statistics</li><li>basic physics- optics mechanics</li><li>Misc- signal processing, numerical analysis</li><li>a bit of aesthetics<br>More dependent on linear algebra<h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h2></li><li>向量/矢量 direciton and length / no absolute starting position</li><li>vector normalization: Magnitude ||<em>a</em>|| unit vector ahat = <em>a</em>/||<em>a</em>||</li><li>图形学中向量缺省设置为列向量<br>$$A=\binom{x}{y}$$</li><li>Dot(scalar) Product-scalar<br>点乘可以快速得到1.两向量间夹角2.一个向量投影到另一向量3.两个向量前后信息</li><li>Cross product<br>叉乘结果永远垂直于a b的平面/右手定则/不满足交换律<br>建立三维空间的空间坐标系(右手坐标系) x X y=z<br>叉乘可以得到</li></ul><p>1.左右信息-右手坐标系里,x叉乘y与z正向一致则x在y右侧<br>2.内外信息<br><img src="https://pic.downk.cc/item/5eca31b6c2a9a83be5dd039a.png" alt=""><br>如图AB叉乘AP BC叉乘BP CA叉乘CP分别都得到左侧信息,那么p就在三角形ABC内部<br>这便是<strong>三角形光栅化基础</strong><br>当叉乘得到0→CornerCase自己规定</p><h2 id="Matrices"><a href="#Matrices" class="headerlink" title="Matrices"></a>Matrices</h2><ul><li>Matrix-Matrix multiplication (M X N)(N x P) = (M x P)<br>无交换律,有结合律</li><li>Matrix-Vector multiplication<br>Treat vector as a column matrix/Key for transforming points</li><li>Transpose of a Matrix<br>transpose(AB)=transpose(B)transpose(A)</li><li>Vector multiplication in Matrix form<br>dot prodect<br><img src="https://pic.downk.cc/item/5eca34b0c2a9a83be5df63dc.png" alt=""><br>cross product<br><img src="https://pic.downk.cc/item/5eca34bdc2a9a83be5df74ca.png" alt=""><br>在旋转推导上,这里非常有用</li></ul><h1 id="03-Transformation"><a href="#03-Transformation" class="headerlink" title="03-Transformation"></a>03-Transformation</h1><h2 id="why-study-transformation"><a href="#why-study-transformation" class="headerlink" title="why study transformation"></a>why study transformation</h2><ul><li>modeling 模型变换<ul><li>translation</li><li>rotation</li><li>scaling</li></ul></li><li>view 视图变换<ul><li>3D to 2D projection<h2 id="2D-transformation"><a href="#2D-transformation" class="headerlink" title="2D transformation"></a>2D transformation</h2><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><blockquote><p>x’ = sx<br>y’ = sy<br><img src="https://pic.downk.cc/item/5eca3fe2c2a9a83be5e9612f.png" alt=""><br>不均匀缩放?<br><img src="https://pic.downk.cc/item/5eca401cc2a9a83be5e991fc.png" alt=""></p></blockquote><h3 id="Reflection-matrix"><a href="#Reflection-matrix" class="headerlink" title="Reflection matrix"></a>Reflection matrix</h3><blockquote><p>horizontal reflection:<br>x’ = -x<br>y’ = y<br><img src="https://pic.downk.cc/item/5eca4067c2a9a83be5e9d7a5.png" alt=""></p></blockquote><h3 id="Shear-matrix"><a href="#Shear-matrix" class="headerlink" title="Shear matrix"></a>Shear matrix</h3><blockquote><p>Hints:<br>Horizontal shift is 0 at y = 0<br>Horizontal shift is a at y = 1<br>Vertical shift is always 0<br>y’ = y<br>x’ = x + a*y<br><img src="https://pic.downk.cc/item/5eca4240c2a9a83be5ebd614.png" alt=""></p></blockquote><h3 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h3><blockquote><p><img src="https://pic.downk.cc/item/5eca446cc2a9a83be5ee2272.png" alt=""><br>默认逆时针旋转<br>如果是反方向旋转,我们直接使用转置矩阵/逆矩阵即可(转置矩阵和逆矩阵相等,正交矩阵)</p></blockquote></li></ul></li></ul><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p><strong>Linear Transforms = Matrices</strong></p><h2 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h2><p><strong>齐次坐标</strong></p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><blockquote><p>Cannot represented in matrix form<br><img src="https://pic.downk.cc/item/5eca45a9c2a9a83be5ef8760.png" alt=""><br>平移变换不是线性变换<br>但是我们不希望把它作为一个特殊例子对待<br>来找一种统一方法表达?(当然没有免费午餐,tradeoff)</p></blockquote><h3 id="Solution-homogenous-coordinates"><a href="#Solution-homogenous-coordinates" class="headerlink" title="Solution: homogenous coordinates"></a>Solution: homogenous coordinates</h3><p><strong>Add a third coordinate</strong></p><blockquote><p>2D point = transpose(x,y,<strong><em>1</em></strong>)<br>2D vector = transpose(x,y,<strong><em>0</em></strong>) #向量平移不变性<br><img src="https://pic.downk.cc/item/5eca48d4c2a9a83be5f2b48f.png" alt=""><br>why?<br>vector + vector = vector<br>point - point = vector<br>point + vector = point<br>point + point = <strong>??</strong><br>To emphasize this, we introduce<br>$$\begin{pmatrix}<br>x\<br>y\<br>z<br>\end{pmatrix} is\ 2D\ point<br>\begin{pmatrix}<br>x/w\<br>y/w\<br>1<br>\end{pmatrix}<br>where\ w!=0$$<br>在齐次坐标系中,两点的和便成了两点的中点</p></blockquote><h3 id="Affine-Transformations"><a href="#Affine-Transformations" class="headerlink" title="Affine Transformations"></a>Affine Transformations</h3><p>Affine map = linear map + translation<br>当我们用homogeneous coordinates表示仿射变换时,变换矩阵的最后一行永远是0,0,1</p><h3 id="Inverse-Transform"><a href="#Inverse-Transform" class="headerlink" title="Inverse Transform"></a>Inverse Transform</h3><p>逆变换和原矩阵在矩阵和几何意义上都是相反的</p><h2 id="Composite-Transform"><a href="#Composite-Transform" class="headerlink" title="Composite Transform"></a>Composite Transform</h2><ul><li>复杂的变换可以由简单变换组合得到</li><li>变换的顺序非常重要</li><li>矩阵乘法不满足交换律→变换顺序有关系</li><li>实际应用时,我们可以先将变换的矩阵进行提前计算,从而用一个矩阵代表非常复杂组合的变换</li></ul><blockquote><p>我们如何对于一个给定的点进行旋转?<br>先将图像平移到原点位置,然后进行旋转,再将其平移回去</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> lessons </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown相关知识</title>
      <link href="/markdown.html"/>
      <url>/markdown.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>本文章主要介绍了markdown的相关语法和几个常用网站</p></blockquote><a id="more"></a><hr><h1 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h1><ul><li>Markdown是一种轻量化标记语言，它允许人们使用易读易写的纯文本格式编写文档。</li><li>用其编写的文档可以导出HTML、Word、图像和PDF等多种格式文档。</li><li>后缀名为.md/.markdown</li></ul><hr><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown标题有两种格式</p><pre><code>// = 和 - 标记语法格式一级标题=======二级标题-------// 事实上只需要一个 = / - 即可实现标题功能</code></pre><hr><pre><code>//使用 # 可以表示 1-6 级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>在一行中使用三个以上的星号、减号、下划线可以建立分割线</p><pre><code>*****-----_____//中间允许增加空格_ _ _  ___*   * *  ***</code></pre><h2 id="字操作"><a href="#字操作" class="headerlink" title="字操作"></a>字操作</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种格式</p><pre><code>*斜体文本***粗体文本*****粗斜体文本***/*上述的 * 可以用 _ 代替但是由于LaTex也需要 _ 所以一般推荐能不用就不用在博客搭建过程中我已对_进行替换*/_斜体文本___粗体文本_____粗斜体文本___</code></pre><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>段落文字添加删除线只需要在文字两端加入两个波浪线即可</p><pre><code>~~增加删除线的文字~~</code></pre><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p><u>下划线</u>通过HTML的标签实现</p><pre><code>&lt;u&gt;增加下划线的文本&lt;/u&gt;</code></pre><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用 * + - 作为列表标记</p><pre><code>* 第一项* 第二项+ 第一项+ 第二项- 第一项- 第二项</code></pre><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字加上.号表示</p><pre><code>1.第一项2.第二项3.第三项</code></pre><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>嵌套只需要在子列表的选项添加四个空格即可</p><pre><code>1.第一项    - 嵌套无序第一元素    - 嵌套无序第二元素2.第二项    - 嵌套无序第一元素    - 嵌套无序第二元素</code></pre><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块引用时在段落开头使用 &gt; 符号</p><pre><code>&gt; 区块引用&gt; 后接空格&gt; 引用别人说的话</code></pre><hr><pre><code>&gt; 区块可嵌套&gt; &gt; 嵌套一层</code></pre><hr><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项</code></pre><hr><pre><code>* 列表中使用区块需要在 &gt; 前添加缩进    &gt; 嵌套    &gt; &gt; 嵌套</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>段落中的一个代码片段可以用反引号把它包起来 <code>printf()</code></p><pre><code>`printf()`</code></pre><hr><p>代码区块使用缩进,四个空格或一个制表符</p><pre><code>(Tab)代码段(Tab)code graph</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code>[链接名称](链接地址)&lt;链接地址&gt;</code></pre><p><a href="www.yqy1997.top">元气源的博客</a><br><a href="http://www.yqy1997.top">http://www.yqy1997.top</a></p><p>我们也可以通过变量设置链接</p><pre><code>此链接用link作为网址变量[yqy博客][link][link]: www.yqy1997.top</code></pre><p>此链接用link作为网址变量<a href="www.yqy1997.top">yqy博客</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>![图片替代文字](图片地址)</code></pre><p><img src="https://pic.downk.cc/item/5ec779d6c2a9a83be57da9bf.gif" alt="bqb"></p><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><ul><li>支持HTML元素</li><li>转义显示特定符号使用反斜杠 \ 进行表示转义</li><li>公式/表格直接网站转换</li></ul><h1 id="Markdown-常用网站"><a href="#Markdown-常用网站" class="headerlink" title="Markdown 常用网站"></a>Markdown 常用网站</h1><ol><li><a href="https://www.tablesgenerator.com/markdown_tables" target="_blank" rel="noopener">markdown 表格生成</a><table><thead><tr><th align="center">测试表格</th><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">甲</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">乙</td><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table></li><li><a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">Latex在线生成</a><br>$$<br>\sum \frac{3}{5}<br>$$<br>//注意要用两端都要用两个美元符号进行包裹,需要使用使在blog头增加 mathjax: true<br>$$<br>\begin{vmatrix}1 &amp; 2 &amp; 3\ 4 &amp;5 &amp;6 \ 7&amp;8 &amp; 9\end{vmatrix}<br>$$</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HexoTagPlugin的使用技巧</title>
      <link href="/hexo_tag_plugin.html"/>
      <url>/hexo_tag_plugin.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>本文章介绍了几种Hexo中TagPlugin的使用技巧</p></blockquote><a id="more"></a><pre><code>阅读全文&lt;!-- more --&gt;</code></pre><h3 id="tag-plugin"><a href="#tag-plugin" class="headerlink" title="tag plugin"></a>tag plugin</h3><ul><li><blockquote class="blockquote-center"><p>世间所有的相遇，都是久别重逢</p></blockquote><p>使文本居中引用-Centered Quote</p></li><li><div class="note default"><p>default 提示块标签</p></div><div class="note primary"><p>primary 提示块标签</p></div><div class="note success"><p>success 提示块标签</p></div><div class="note info"><p>info 提示块标签</p></div><div class="note warning"><p>warning 提示块标签</p></div><div class="note danger"><p>danger 提示块标签</p></div><p>提示块-Note</p></li><li><span class="label default">默认</span> <span class="label primary">主要</span> <span class="label success">成功</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> <span class="label success">这是成功的信息</span><p>标签-Label</p></li><li><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">选项卡1</a></li><li class="tab"><a href="#tab-2">选项卡2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 1</strong></p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 3</strong> 名字为A</p></div></div></div><p>选项卡-Tabs</p></li></ul><ul><li>% button url, text, icon [class], [title] % ###左右加花括号<ul><li>url 绝对/相对URL</li><li>text 按钮文字</li><li>icon FontAwesome图标名称</li><li>clasee FontAwesome 类：fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5X ，可选参数</li><li>title 鼠标悬停时的工具提示<div><a class="btn" href="http://www.yqy1997.top/" title="go back to main page"><i class="fa fa-home fa-fw"></i>首页</a></div>/n 例子<div class="text-center"><div><a class="btn" href="http://www.yqy1997.top/" title="这是小丁的个人博客首页"><i class="fa fa-home fa-fw"></i>首页</a> <a class="btn" href="http://www.yqy1997.top/" title="豆瓣电影"><i class="fa fa-film fa-fw"></i>观影</a> <a class="btn" href="http://www.yqy1997.top/" title="豆瓣读书"><i class="fa fa-book fa-fw"></i>阅读</a></div></div>/n 居中</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待整理区域</title>
      <link href="/messy.html"/>
      <url>/messy.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Aug 01 2020 18:21:36 GMT+0800 (GMT+08:00) --><a id="more"></a><p>$$<br>\sum \frac{3}{5}<br>$$</p><p><strong>asdfkljg</strong></p><p><a href="https://www.mathcha.io/editor" target="_blank" rel="noopener">https://www.mathcha.io/editor</a> 数学公式编辑器,比Latex还好用</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>def adef bdef c</code></pre><h2 id="https-copytranslator-github-io"><a href="#https-copytranslator-github-io" class="headerlink" title="https://copytranslator.github.io/"></a><a href="https://copytranslator.github.io/" target="_blank" rel="noopener">https://copytranslator.github.io/</a></h2><h2 id="https-www-superbed-cn-聚合图床"><a href="#https-www-superbed-cn-聚合图床" class="headerlink" title="https://www.superbed.cn/  聚合图床"></a><a href="https://www.superbed.cn/" target="_blank" rel="noopener">https://www.superbed.cn/</a> <strong>聚合图床</strong></h2><h2 id="https-leancloud-cn-dashboard-applist-html-apps-leancloud-管理评论-计数信息-密码分大小写"><a href="#https-leancloud-cn-dashboard-applist-html-apps-leancloud-管理评论-计数信息-密码分大小写" class="headerlink" title="https://leancloud.cn/dashboard/applist.html#/apps leancloud 管理评论 计数信息 密码分大小写"></a><a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">https://leancloud.cn/dashboard/applist.html#/apps</a> leancloud 管理评论 计数信息 密码分大小写</h2><h2 id="https-search-google-com-search-console-sitemaps-resource-id-http-3A-2F-2Fwww-yqy1997-top-2F-谷歌站点地图"><a href="#https-search-google-com-search-console-sitemaps-resource-id-http-3A-2F-2Fwww-yqy1997-top-2F-谷歌站点地图" class="headerlink" title="https://search.google.com/search-console/sitemaps?resource_id=http%3A%2F%2Fwww.yqy1997.top%2F 谷歌站点地图"></a><a href="https://search.google.com/search-console/sitemaps?resource_id=http%3A%2F%2Fwww.yqy1997.top%2F" target="_blank" rel="noopener">https://search.google.com/search-console/sitemaps?resource_id=http%3A%2F%2Fwww.yqy1997.top%2F</a> 谷歌站点地图</h2><h2 id="https-ziyuan-baidu-com-linksubmit-index-site-http-www-yqy1997-top-百度站点地图"><a href="#https-ziyuan-baidu-com-linksubmit-index-site-http-www-yqy1997-top-百度站点地图" class="headerlink" title="https://ziyuan.baidu.com/linksubmit/index?site=http://www.yqy1997.top/ 百度站点地图"></a><a href="https://ziyuan.baidu.com/linksubmit/index?site=http://www.yqy1997.top/" target="_blank" rel="noopener">https://ziyuan.baidu.com/linksubmit/index?site=http://www.yqy1997.top/</a> 百度站点地图</h2><h2 id="黄金神威"><a href="#黄金神威" class="headerlink" title="黄金神威"></a>黄金神威</h2><h2 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h2><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
